[
  {
    "Id": "1080660",
    "ThreadId": "453433",
    "Html": "Hi there,\r<br />\n<br />\n I'm very new to powershell and am using it to try to automate some processes at work, i've got a few questions about how to speed this up some. After each block completes, there's a long pause.\r<br />\n<br />\nHere is what I've got for code. Its taken directly from the UI Spy program for the most part.<br />\n<pre><code>Get-UIAWindow -Class 'ThunderRT6FormDC' -Name 'Administrator Tools' |\nGet-UIAPane -Class 'SSTabCtlWndClass' | Get-UIAList  -AutomationId '29' -Class 'ThunderRT6ListBox' |\nInvoke-UIAControlClick | Set-UIAControlText $User | Get-UIAListItem -Name $user | Invoke-UIAControlClick -DoubleClick;\n\nGet-UIAWindow -Class 'ThunderRT6FormDC' -Name 'Administrator Tools' | `\nGet-UIAPane -Class 'ToolbarWndClass' | `\nGet-UIAToolBar -Class 'ToolbarWindow32' | `\nGet-UIAButton -AutomationId 'Item 101' -Name 'Modify Current User' | Invoke-UIAControlClick;\n\nGet-UIAWindow -Class 'ThunderRT6FormDC' -Name 'Administrator Tools' | `\nGet-UIAPane -Class 'SSTabCtlWndClass' | `\nGet-UIAPane -Class 'SSTabCtlWndClass' | `\nGet-UIAEdit -AutomationId '45' -Class 'ThunderRT6TextBox' | Set-UIAControlText $userAbsent;\n\nwrite-host &quot;done&quot;;\n</code></pre>\n\n",
    "PostedDate": "2013-08-14T11:34:34.133-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1080746",
    "ThreadId": "453433",
    "Html": "Hi jiffywhip,<br />\nfirst of all, the spy (as any code recorder) honestly writes all controls in the hierarchy exactly as they are placed in the Automation tree. Generated code is often a raw mass that I'd recommend to polish.<br />\nFor example, in many cases you can cut out the -Class parameter. The parameter -AutomationId with value 29, 101 or 45 is a candidate to be cut out (it seems to be a value that application under test generated runtime).<br />\nWe need (to the extent that controls remain recognizable) to shorten raw code in two ways:<br />\n1) it'd have less hops, i.e. <strong>get-uiawindow | get-control | get-control | get-control</strong> -&gt; <strong>get-uiawindow | get-control | get-control</strong> or even <strong>get-uiawindow | get-control</strong>. Every hop is a query.<br />\n2) less properties are used for search (automatically generated AutomationIds (these 29 and 45), -Class that could sometimes vary from one operating system to another), i.e.<br />\n<strong>Get-control -class -name -automationid</strong> -&gt; <strong>Get-control -name</strong> or <strong>Get-control -automationid</strong><br />\nMy version of this code would look like (it's just an imaginary example!):<br />\n<pre><code>Get-UIAWindow -Name *Admin*tools* | Get-UIAList  -Class 'ThunderRT6ListBox' |\nInvoke-UIAControlClick | Set-UIAControlText $User | Get-UIAListItem -Name $user | Invoke-UIAControlClick -DoubleClick;\n\nGet-UIAWindow -Name *Admin*tools* | `\nGet-UIAToolBar -Class 'ToolbarWindow32' | `\nGet-UIAButton -Name 'Modify Current User' | Invoke-UIAControlClick;\n\nGet-UIAWindow -Name *Admin*tools* | `\nGet-UIAEdit -Class 'ThunderRT6TextBox' | Set-UIAControlText $userAbsent;\n\nwrite-host &quot;done&quot;;</code></pre>\n\nIf the code waits for something AFTER each block of code, I think the problem is in getting the window. Supposing that the most of other windows are minimized or closed (the more normal/maximized windows, the slower UI Automation), I'd suggest experimenting with getting a window via process name, process id, process object or a combination:<br />\n<pre><code>Get-UIAWindow -pn calc\nGet-UIAWindow -p (Get-Process calc)\nGet-UIAWindow -pid (Get-Process calc).Id</code></pre>\n\nDepending on which version you use (0.8.5, 0.8.6 betas), there could be more options, for example:<br />\n<pre><code>Get-UIAWindow -Win32 -Name *calc* # via EnumChildWindows</code></pre>\n\nYou can try several variants with the Measure-Command cmdlet:<br />\n<pre><code>Measure-Command -Expression { Get-UIAWindow -Name *calc*; }</code></pre>\n\nFinally, if you need a lot of applications being run at the time you get a window, there may be a limitation (UIAutomation enumerates windows in a certain way. The more windows, the slower queries).<br />\nAnother option for you is getting the desktop object and enumerating/filtering children:<br />\n<pre><code>Get-UIADesktop | Get-UIAControlChildren | ?{ $_.Current.Name -like &quot;*calc*&quot; }</code></pre>\n\nthis way at least demonstrates how many windows UI Automation enumerates.<br />\n",
    "PostedDate": "2013-08-14T14:53:50.643-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]