[
  {
    "Id": "1087947",
    "ThreadId": "455396",
    "Html": "Hello for everyone.\r<br />\n<br />\nI' m Searching a right mode for invoke a click event into button Get-UIAButton object, the conditions are:<br />\n<ul>\n<li>The buttons belong to a differents Get-UIAWindow same application.</li>\n<li>The invoke should be applied at the same time or almost same time.</li>\n<li>\nBoth buttons have same automation id<br />\n</li>\n</ul>\nI have tried using different runspaces but it does not work, apparently the buttons does not receive the event.\r<br />\n<br />\nHere is the code\r<br />\nBest Regards...<br />\n<pre><code>cls;\n#Function that will be used to process runspace jobs\nFunction Get-RunspaceData {\n  [cmdletbinding()]\n  Param(\n    [System.Collections.ArrayList]$runspaces,\n    [switch]$Wait\n  )\n  Do {\n    $more = $false         \n    Foreach($runspace in $runspaces) {\n      If ($runspace.Runspace.isCompleted) {\n        $runspace.powershell.EndInvoke($runspace.Runspace)\n        $runspace.powershell.dispose()\n        $runspace.Runspace = $null\n        $runspace.powershell = $null\n        #$Script:i++                  \n      } ElseIf ($runspace.Runspace -ne $null) {\n        $more = $true\n      }\n    }\n    If ($more -AND $PSBoundParameters['Wait']) {\n      Start-Sleep -Milliseconds 100\n    }   \n    #Clean out unused runspace jobs\n    $temphash = $runspaces.clone()\n    $temphash | Where {\n      $_.runspace -eq $Null\n    } | ForEach {\n      Write-Verbose (&quot;Removing {0}&quot; -f $_.computer)\n      $Runspaces.remove($_)\n    }             \n  } while ($more -AND $PSBoundParameters['Wait'])\n}\n\n\n$ScriptBlock = \n{\nParam ($WindowName)                 \n    \n    Start-Sleep -seconds 10   \n    Write-Host &quot;Saving Data into Window :&quot; $WindowName\n    # =============== Save Changes =================\n    # Save Change\n    Get-UIAWindow -name $WindowName | `\n    Get-UIAButton -AutomationId 'btnSave' | `\n   Invoke-UIAButtonClick;\n}\n\nFunction Process-AsyncWorkload{\n  [cmdletbinding()]\n  Param(\n    [ScriptBlock]$ScriptBlock,\n    [Array]$Instances,\n    [int]$Throttle = 15\n  )\n  Begin {\n    # Define hash table for Get-RunspaceData function\n    $runspacehash = @{}\n    # Define async job pools\n    $sessionstate = [system.management.automation.runspaces.initialsessionstate]::CreateDefault()\n    $runspacepool = [runspacefactory]::CreateRunspacePool(1, $Throttle, $sessionstate, $Host)\n    $runspacepool.Open()  \n    $runspaces = New-Object System.Collections.ArrayList        \n  }\n  Process {\n    write-verbose &quot;Starting async processing&quot;\n    ForEach ($Parameter in $Instances) {\n      # Create the powershell instance and supply the scriptblock with the other parameters\n      Try{\n        $powershell = [powershell]::Create().AddScript($ScriptBlock)\n        if ($Parameter -is [System.Collections.Hashtable]){\n          $Parameter.Keys | foreach{\n            $powershell.AddArgument($Parameter[$_]) | Out-Null\n          }\n        } else {\n          write-verbose &quot;Setting up async job with parameter: $Parameter&quot;\n          $powershell.AddArgument($Parameter) | Out-Null\n        }\n        \n        # Add the runspace into the powershell instance\n        $powershell.RunspacePool = $runspacepool\n        # Create a temporary collection for each runspace\n        $temp = &quot;&quot; | Select-Object PowerShell,Runspace\n        $temp.PowerShell = $powershell\n        \n        # Save the handle output when calling BeginInvoke() that will be used later to end the runspace\n        $temp.Runspace = $powershell.BeginInvoke()\n        #Write-Verbose (&quot;Adding {0} to collection&quot; -f $temp.Computer)\n        $runspaces.Add($temp) | Out-Null\n      } Catch {\n        Write-Warning (&quot;{0} Error&quot; -f $_.Exception.Message)\n        Break\n      }\n      # Verifying async job status\n      Write-Verbose (&quot;Checking status of runspace jobs&quot;)\n      Get-RunspaceData -runspaces $runspaces -Verbose\n    }                        \n  }\n  End {                     \n    Write-Verbose (\n      &quot;Finish processing the remaining runspace jobs: {0}&quot; -f (\n        @(($runspaces | Where {$_.Runspace -ne $Null}).Count)))\n        \n    Get-RunspaceData -runspaces $runspaces -Wait -Verbose\n    Write-Verbose (&quot;Closing the runspace pool&quot;)\n    $runspacepool.close()\n  }\n}\n \n\n$windowA = &quot;*Silo*&quot;\n$windowB= &quot;*Scale*&quot;\n\n\n#$Button2 = Get-UIAWindow -name *Scale* | `\n#Get-UIAButton -AutomationId 'btnSave'\n\n$Windows = @($windowA , $windowB)\n\nProcess-AsyncWorkload -ScriptBlock $ScriptBlock  -Instances $Windows -Verbose___\n</code></pre>\n\n",
    "PostedDate": "2013-09-03T14:16:33.17-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1088237",
    "ThreadId": "455396",
    "Html": "Hi juan_ramon_m,\r<br />\nthe first idea on how to click anything in another window was to store the button from another window in a variable:<br />\n<pre><code>ipmo C:\\......\\UIAutomation.dll\n# button 1 from the first app instance\n$button1inWindow1 = Start-Process calc -PassThru | Get-UIAWindow | Get-UIAButton 1;\n# button 2 from the second app instance\n$button2inWindow2 = Start-Process calc -PassThru | Get-UIAWindow | Get-UIAButton 2;\n# you could move one of windows just now to watch both clicks\n$button1inWindow1 | Invoke-UIAButtonClick; $button2inWindow2 | Invoke-UIAButtonClick;\n</code></pre>\n\nThe second example is how to click a button that is under a modal window:<br />\n<pre><code># Just button 1\n$button1inWindow1 = Start-Process calc -PassThru | Get-UIAWindow | Get-UIAButton 1;\n# opening the About window\nGet-UIAMenuItem -Name help | Invoke-UIAMenuItemExpand | Get-UIAMenuItem -Name *about* | Invoke-UIAMenuItemClick;\n# clicking our previously saved button 1\n$button1inWindow1 | Invoke-UIAButtonClick;</code></pre>\n\nPlease notice that some (rare) application's windows could perform a kind of self-refresh, after which some controls could be re-painted and given a new handle.\r<br />\n<br />\nRegarding your script (ahh, if it'd been based on something globally available like calc.exe! :)), I'd say that palying with runspaces, threads and so on may be fatal for GUI automation: it is sensitive whether it's running on a wrong thread...<br />\n",
    "PostedDate": "2013-09-04T06:56:13.22-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]