[
  {
    "Id": "761175",
    "ThreadId": "310878",
    "Html": "\r\n<p>Questions about use of the framework</p>\r\n",
    "PostedDate": "2012-02-13T11:59:31-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "800008",
    "ThreadId": "310878",
    "Html": "<p>How can I set a textbox value? I try this:</p>\r\n<p>&nbsp;</p>\r\n<p>$EntTab | Get-UIATextBox -AutomationID 'PART_TextBox' | Invoke-SetUIAControlText 'VCRDesign04'</p>\r\n<p>&nbsp;</p>\r\n<p>It can find the textbox but doesn't set the value.</p>",
    "PostedDate": "2012-02-25T23:33:17.947-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "803830",
    "ThreadId": "310878",
    "Html": "<blockquote style=\"border: solid .1em #ccc; font-style: italic; margin: .25em 1em 0 1em; padding: 0 .25em 0 .25em;\"><strong>behradz wrote:</strong><br />\r\n<p>How can I set a textbox value? I try this:</p>\r\n<p>$EntTab | Get-UIATextBox -AutomationID 'PART_TextBox' | Invoke-SetUIAControlText 'VCRDesign04'</p>\r\n<p>It can find the textbox but doesn't set the value.</p>\r\n</blockquote>\r\n<p>Hello behradz,</p>\r\n<p>setting text into a textbox/edit can work strangely in many cases:</p>\r\n<p>autocomplete is on may require you to input characters one by one (it heavily depends on the way programmers use event's invoking)</p>\r\n<p>About the input:&nbsp;</p>\r\n<p>1)&nbsp;<span>Invoke-SetUIAControlText - do you have rather old version of the module?</span></p>\r\n<p>maybe, you wanted to write: Invoke-UIAControlText (seemingly it might be called so before I rearranged names againts Automation patterns) or Set-UIAControlText?</p>\r\n<p>2) for example, Quest PowerGui 3.2 ScriptEditor -&gt; the textbox in the toolbar where the user can type in script paramaters:</p>\r\n<p>Get-UIAWindow -ProcessName scripteditor_x86 | Get-UIATextBox -AutomationId 132468 | Set-UIAControlText -Text 'text to the text box'</p>\r\n<p>(through Win32)</p>\r\n<p>another example is a simple winforms app (just one text box on the form):</p>\r\n<p>Get-UIAWindow -n as | Get-UIATextBox -au textBox1 | Set-UIATextBoxText -Text \"asdfasdf\"</p>\r\n<p>please notice the need to explicitly set the -Text parameter, because default parameter is -InputObject (AutomatinElement)</p>\r\n<p>3) in many cases setting the text may work bad as MS UIautomation is not exceptionally good on it</p>\r\n<p>Our framework provide you with the following debugging means:</p>\r\n<p>the -Verbose parameter that can be set exactly to the cmdlet whose work is dubious (it's used in our tests of cmdlets)</p>\r\n<p>the UIAutomation.log in the user's %TEMP% (you need quit the powershell session to read it).</p>",
    "PostedDate": "2012-03-01T08:17:32.61-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "803915",
    "ThreadId": "310878",
    "Html": "<p>Thanks for your very elaborated description. Now I have it working. I have a problem though:</p>\r\n<p>UIAutomation is very slow. I think the reason is that we are not reusing the objects and load them for every transaction (change or search). Is there any way we can reuse the main object?</p>",
    "PostedDate": "2012-03-01T11:16:31.007-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "803938",
    "ThreadId": "310878",
    "Html": "<blockquote style=\"border: solid .1em #ccc; font-style: italic; margin: .25em 1em 0 1em; padding: 0 .25em 0 .25em;\"><strong>behradz wrote:</strong><br />\n<p>I have a problem though:</p>\n<p>UIAutomation is very slow. I think the reason is that we are not reusing the objects and load them for every transaction (change or search). Is there any way we can reuse the main object?</p>\n</blockquote>\n<p>Are you speaking about the PowerShell module or the MS UI Automation library? Even the library is slower that direct using of Win32 API...</p>\n<p>Okay, let's try to find out what can be an impediment to the product speed.</p>\n<p>1) first and foremost, there is possibly the stupid default setting: [UIAutomation.Mode]::Profile -eq [UIAutomation.Modes]::Presentation</p>\n<p>This sets 500 milliseconds' timeout on every successful or failed operation. Why? This is THE presentation mode: highlighted controls, slow motion and so on, so that any IT boss could run it with minimal efforts and present to himself/herself and to some  higher personnel. :)</p>\n<p>Maybe, this is wrong default, but ANY default is not good unless I publish the User Guide. :) I'll be trying out something this week.</p>\n<p>There is the cmdlet that display module settings: Show-UIAModuleSettings and there is a very primitive system of profiles (or modes):</p>\n<p>&nbsp;&nbsp;[UIAutomation.Mode]::Profile =&nbsp;[UIAutomation.Modes]::Presentation/Normal/Debug</p>\n<p>Try the Normal mode, it has no delays (and no highlight) or set settings by hands: [UIAutomaiton.Preferences]::... .</p>\n<p>2) The Log. The enormous log. There are no log levels for now, so that you can simply switch it off: [UIAutomation.Preferences]::Log=$false</p>\n<p>3) Highlighter can be switched off too: [UIAutomation.Preferences]::HIghlight=$false;</p>\n<p>4) OnSuccessAction, OnErrorAction, OnSleepAction: they couldn't be switched off right now, but I'll add the possibility to switch them off the next release (a small help but...)</p>\n<p>5) If you don't need in filtered errors, you may decrease the number of saved errors: [UIAutomation.Preferences]::MaximumErrorCount, a small time saving though.</p>\n<p>6) [UiAutomation.Preferences]::OnErrorScreenshot=$false also saves your script's time.</p>\n<p>After you did or didn't apply the settings above, now I'm ready to discuss how the module works, and why, and what is possible to do.</p>",
    "PostedDate": "2012-03-01T11:55:31.38-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "803943",
    "ThreadId": "310878",
    "Html": "<p>Despite many tricks we can or can't implement in the code, we must pay for pipelining, code reuse, encapsulating, the code divided into cmdlets with user-friendly names and so on...</p>\n<p>1) The user issues the command: Get-UIAWindows -p $processname</p>\n<p>the AutomationElement is automatically saved to the [UIAutomation.CurrentData]::CurrentWindow variable.</p>\n<p>Unless you are testing a wizard, especially setup wizard, and unless your application often emits dialogs, windows or similar, you further can work with controls without getting the window again and again:</p>\n<p>Get-UIAMenuItem -n ... | Invoke-UIAMenuItemClick; Get-UIAButton | Invoke-UIAButtonClick; ...</p>\n<p>This is the same (internally) as&nbsp;</p>\n<p>[UIAutomation.CurrentData]::CurrentWindow |&nbsp;Get-UIAMenuItem -n ... | Invoke-UIAMenuItemClick;</p>\n<p>[UIAutomation.CurrentData]::CurrentWindow |&nbsp;Get-UIAButton | Invoke-UIAButtonClick;</p>\n<p>We can't repeat this trick with a control because there would be a mess (an implied control? noooo)</p>\n<p>2) For now almost all the query are done using TreeScope.Subtree (or Descendants) search. It's possible to do (for advanced users) the deep of search parametrized, as Get-UIAButton -Scope Children/Descendants; Get-UIAPane -Scope Children/Ancestors, etc.</p>\n<p>3) There are several cmdlets that allow you to do simply things without usual usability like Get-UIA[ControlType]</p>\n<p>They are: Get-UIAControlChildren (search only among immediate children), Get-UIAControlParent (the immediate parent), maybe some else that right now are out of my near memory... :)</p>\n<p>4) using of variables similarly to the sample of your code:</p>\n<p>$tabitem = (Get-UIAWindows -n .... | Get-UIATabItem);</p>\n<p>Get-UIATextBox -InputObject $tabitem -au ...;</p>\n<p>Get-UIAButton -InputObject $tabitem -n OK;</p>\n<p>&nbsp;</p>\n<p>However, MS UiAutomation will never so fast as SendMessage/PostMessage, and the PowerShell module will never faster than bare MS UIAutomation, I hope there is the place for further optimization... Just when more and more people will demand the speed, we'll  have to optimize it in some way.</p>\n<p>On the other hand, the usability for everyone that powershell provides (pieces of code called cmdlets are much more useful than dotten notation, to me.) and the ability to run almost everything without writing much code (click a control and check a Windows or web service from the same script just in several lines of code), and the fact that pieces of code (cmdlets) are tested as pieces of code, these advantages should win. ;)</p>",
    "PostedDate": "2012-03-01T12:10:32.51-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "803981",
    "ThreadId": "310878",
    "Html": "<p>You work is really appreciated and I understand what you say but the speed could be a real issue as this is to be used for automated testing of hundred of test cases.</p>\r\n<p>probably it can work faster by caching ui elements inside the main object. &nbsp;You can see my code below and let me know if there are better way of doing it. As you see I am caching the&nbsp;MainWindow but if it could cache the visual tree inside it, it could go much faster.</p>\r\n<p>&nbsp;</p>\r\n<p>The other thing is that there were no method to find the UIAutomation object by processID or mainWindow hwnd. You may like to consider adding it.</p>\r\n<p>&nbsp;</p>\r\n<p>--------------------------------------------------</p>\r\n<p>$Process=Start-Process -FilePath \"C:\\Config.exe\"<br />sleep 2</p>\r\n<p><br />[Reflection.Assembly]::LoadFile('C:\\Program Files\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\UIAutomationClient.dll')[Reflection.Assembly]::LoadFile('C:\\Program Files\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\UIAutomationTypes.dll')</p>\r\n<p><br />$MainWindow=[Windows.Automation.AutomationElement]::FromHandle($Process.MainWindowHandle)</p>\r\n<p><br />$EntTab= &nbsp; &nbsp; $MainWindow &nbsp;| Get-UIATabItem &nbsp; &nbsp;-AutomationID 'tabENT' -Title 'Enterprise'</p>\r\n<p>$DBServer= &nbsp; &nbsp; &nbsp; $EntTab &nbsp;| Get-UIATextBox &nbsp; &nbsp;-AutomationID 'PART_TextBox'</p>\r\n<p>$DBAuth= &nbsp; &nbsp; &nbsp; &nbsp; $EntTab &nbsp;| Get-UIATextBox &nbsp; &nbsp;-AutomationID 'PART_EditableTextBox'</p>\r\n<p>$DBPassword= &nbsp; &nbsp; $EntTab &nbsp;| Get-UIAEdit &nbsp; &nbsp; &nbsp; -AutomationID 'passwordBox'</p>\r\n<p>$DBDatabase= &nbsp; &nbsp; $EntTab &nbsp;| Get-UIAText &nbsp; &nbsp;-AutomationID 'txtDatabaseName' | Get-UIATextBox -AutomationID 'PART_TextBox'</p>\r\n<p>$btnDBConnect=$MainWindow | Get-UIAButton -AutomationID 'btnGetValues'</p>\r\n<p>$PortsTab= &nbsp; $MainWindow &nbsp;| Get-UIAGroup &nbsp;-AutomationID 'gboxPorts'</p>\r\n<p>$PortBase= &nbsp; &nbsp; $PortsTab &nbsp;| Get-UIAText &nbsp; -AutomationID 'txtBasePort' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Get-UIATextBox -AutomationID 'PART_TextBox'</p>\r\n<p>$PortSecurity= $PortsTab &nbsp;| Get-UIAText &nbsp; -AutomationID 'txtAuthenticationPort' &nbsp;| Get-UIATextBox -AutomationID 'PART_TextBox'</p>\r\n<p>$PortMigration=$PortsTab &nbsp;| Get-UIAText &nbsp; -AutomationID'txtDMPort' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| Get-UIATextBox -AutomationID 'PART_TextBox'</p>\r\n<p>$PortPersonal= $PortsTab &nbsp;| Get-UIAText &nbsp; -AutomationID 'txtPersonalizationPort' | Get-UIATextBox -AutomationID 'PART_TextBox'</p>\r\n<p>$btnExit= &nbsp; &nbsp;$MainWindow &nbsp;| Get-UIAButton -AutomationID 'PART_Button' -Title 'Exit'</p>\r\n<p>$btnSave= &nbsp; &nbsp;$MainWindow &nbsp;| Get-UIAButton -AutomationID 'PART_Button' -Title 'Save Configuration'</p>\r\n<p>$btnReset= &nbsp; $MainWindow &nbsp;| Get-UIAButton -AutomationID 'PART_Button' -Title 'Reset'</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-03-01T12:59:41.76-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "804002",
    "ThreadId": "310878",
    "Html": "<p>1) Start the script with setting the Normal mode:</p>\r\n<p>[UIAutomation.Mode]::Profile = [UIAutomation.Modes]::Normal</p>\r\n<p>or set zero delays manually:</p>\r\n<p>[UIAutomation.Preferences]::OnSuccessDelay=0</p>\r\n<p>[UIAutomation.Preferences]::OnErrorDelay=0</p>\r\n<p>[UIAutomation.Preferences]::Log=$false</p>\r\n<p>2) You can rewrite the beginning in the following way:</p>\r\n<p>Start-Process -FilePath \"C:\\Config.exe\"</p>\r\n<p>$MainWindow=Get-UIAWindow -ProcessName Config -Seconds 20;</p>\r\n<p>comments: we hate sleeps! It's always bad, it and SendKeys, the thing you are never sure in. Get-Window/Control and Wait-ControlIsEnabled cmdlets are born with the cycle inside. They will wait the time you set through the -Seconds [sec] or -Timeout [millisec] parameters.</p>\r\n<p>The only problem is some wizards, where after pressing the Next button, the handle of the main window changes.</p>\r\n<p>The code above will wait for a window belonging to the process you chose. If no window will be available after the time, it'll return an exception.</p>\r\n<p>3) If you window is stable (no unexpected child windows will appear), you are free to omit the main window variable:</p>\r\n<p>$btnExit= &nbsp; &nbsp;Get-UIAButton -AutomationID 'PART_Button' -Title 'Exit'</p>\r\n<p>$btnSave= &nbsp; &nbsp;Get-UIAButton -AutomationID 'PART_Button' -Title 'Save Configuration'</p>\r\n<p>$btnReset= &nbsp; Get-UIAButton -AutomationID 'PART_Button' -Title 'Reset'</p>\r\n<p>$MainWindow -eq [UIAutomation.CurrentData]::CurrentWindow</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-03-01T13:25:08.207-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "804018",
    "ThreadId": "310878",
    "Html": "<p>Seemingly, getting a lot of various windows is a rare case. So that the user will not need getting a window by PID very often. Since this is not a frequent need, nothing prevents the user from issuing the command:</p>\r\n<p>Get-UIAWindow -p (Get-Process -Id 1234).ProcessName | Get-UIAsomething ...</p>\r\n<p>Thsi module contains three hundred of cmdlets (eightly or ninety percent of them are generated only for usability:)), some of them contain parameters that are taken from the mind, not from the MS guidelines. Why do the life of the user more complicated, inventing (sometimes controversial) cmdlets and parameters? Get-Process is enough, the good thing by MS.</p>\r\n<p>Now about handles.&nbsp;</p>\r\n<p>1) not every control has a handle. Grid items, actions at the right of MMC 3.0, menu items, many ocntrol can have no handle at all.&nbsp;</p>\r\n<p>The ideology of the module is to use Win32 (read: heavily related to using a handle) functions only when it's unavoidable.</p>\r\n<p>For example, UI Automation failed to click a control or to run its context menu. There rule handles and Win32 API (Invoke-UIAControlClick, Invoke-UIAControlContextMenu are the thing I uses rather often with some controls). Even more, you can pipe a handless control to it, and Win32 cmdlet calculated x and y from an ancestor that has a handle and clicks a handless control...</p>\r\n<p>2) What do you plan to optimize? Time? How?</p>\r\n<p>(Get-UIAsometing).Current.NativeWindowHandle | Get-UIAcmdletThatConsumesHandle</p>\r\n<p>What is the idea if you use here the same Get-UIAsomething? no time saving, in my opinion.</p>\r\n<p><strong>Please give me more information about how you would use handles?</strong></p>\r\n<p>3) About your code: why do you do so many Get-?</p>\r\n<p>If you need to check that there are these controls that you've listed in the code (unit tests that check that the form showed all the controls?), consider using ControlState cmdlets:</p>\r\n<p>run your application and run the following:</p>\r\n<p>Get-UIAWindow ... | Get-UIAControlChildren/Descendants | ConvertTo-UIASearchCriteria</p>\r\n<p>It'll return hashtables as powershell text: @{Name=\"...\";AutomationId=\"textBox1\";....}</p>\r\n<p>After that select all of them that you need, Next cut out all unnecessary like ProcessId, NativeWindowHandle (different on any new run).</p>\r\n<p>After all you'll have something like:</p>\r\n<p>Test-UIAControlState -SearchCriteria @{<span>AutomationID='PART_Button';Name=</span><span>'Exit'</span>},@{Name=<span>'Save Configuration';IsEnabled=$true</span>},@{},@{}</p>\r\n<p>If the cmdlet finds ALL the controls that match hashtable (i.e. the 'Save Configuration' button is enabled and the Exit button has the 'PART_Button' automationid), it'll return $true. Ontherwise (i.e. even only one conditions is wrong), $false.</p>\r\n<p>As I can see, you use not the last version? the -Title parameters is an alias, instead please start using -Name (it replaces the first).</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks you for feature proposals and the use of the module.</p>",
    "PostedDate": "2012-03-01T13:55:09.24-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "804019",
    "ThreadId": "310878",
    "Html": "<p>To conclude, you can try to produce almost an one-liner (specifically to your example that only Get-s control the most of the time) or several one-liners:</p>\r\n<p>Start-Process -FilePath \"C:\\Config.exe\"</p>\r\n<p>Get-UIAWindow -ProcessName Config -Seconds 20 | Test-UIAControlState -SearchCriteria `</p>\r\n<p>@{Name='button name'}, @{automationid='....';Name='some name'}, @{controltype='button';isoffscreen=$false;classname='.....';name='...'}, ....</p>\r\n<p>Test-UIAControlState and Wait-UIAControlState (do it in the cycle until timeout expires) return $true if all the conditions are $true (one control per one hashtable).</p>",
    "PostedDate": "2012-03-01T14:02:56.977-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "804193",
    "ThreadId": "310878",
    "Html": "<p>Thanks for your help. I have to apply what you said but about find by processID, I don't think your solution work for me and many other people as well. As a QA it is not wise that you find a process by name at all! That can be another process and totally mess up your tests reliability. I want to start a process for myself and make sure I am dealing with that instance. So I propose adding following two switches to Get-UIAWindow:</p>\r\n<p>&nbsp;</p>\r\n<p>Get-UIAWindow -Process $ProcessObject</p>\r\n<p>Get-UIAWindow -ProcessID $ProcessID</p>\r\n<p>Get-UIAWindow -WindowHand $hwnd</p>",
    "PostedDate": "2012-03-01T23:10:00.7-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "854769",
    "ThreadId": "310878",
    "Html": "\r\n<p>Please, give some examples how to wait for new window with unpredictable Name value(it can be various error or notify messages)?; how to enumerate all opened windows? I want to remove windows to clean desktop after unsuccessful run of application.</p>\r\n",
    "PostedDate": "2012-06-27T23:41:21.493-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "854901",
    "ThreadId": "310878",
    "Html": "<p>Hello <a class=\"UserProfileLink\" href=\"http://www.codeplex.com/site/users/view/JUSTASM\">JUSTASM</a>,</p>\r\n<p>1) how to wait for a new window with random Name?</p>\r\n<p>first of all, there are ways to take a window by its ProcessId/pid, ProcessName/pn and its process object. If you issue the process, all the following would work:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\"># you've set a name for process somewhere in the code</span>\r\n<span style=\"color: orangered;\">$processName</span> <span style=\"color: gray;\">=</span> <span style=\"color: #a31515;\">\"calc\"</span>;\r\n\r\n<span style=\"color: green;\"># get the window by its process id</span>\r\nGet<span style=\"color: gray;\">-</span>UIAWindow <span style=\"color: gray;\">-</span>pid (Start<span style=\"color: gray;\">-</span>Process <span style=\"color: orangered;\">$processName</span> <span style=\"color: gray;\">-</span>PassThru).Id\r\n\r\n<span style=\"color: green;\"># get the window by its process name</span>\r\nGet<span style=\"color: gray;\">-</span>UIAWindow <span style=\"color: gray;\">-</span>pn (Start<span style=\"color: gray;\">-</span>Process <span style=\"color: orangered;\">$processName</span> <span style=\"color: gray;\">-</span>PassThru).ProcessName\r\n</pre>\r\n</div>\r\n</p>\r\n<p>second, you also can use a part of its name (supposing that some part of a name is uncahngeble from run to run);</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>Start<span style=\"color: gray;\">-</span>Process calc; Get<span style=\"color: gray;\">-</span>UIAWindow <span style=\"color: gray;\">-</span>n <span style=\"color: gray;\">*</span>lato<span style=\"color: gray;\">*</span>\r\n</pre>\r\n</div>\r\n</p>\r\n<p>Note that rare windows that are not seen by MS Automation and could be found by using FindWindow, still don't support wild cards (it will be done relatively soon). I know only one such an example: on a 64-bit OS, a 32-bit MMC snap-in that is not shown in the TaskBar, runs its own window instead of the main MMC window (It's really rare case).</p>\r\n<p>&nbsp;</p>\r\n<p>2) Which opened windows do you want to enumerate?</p>\r\n<p>2.1) window with known to you a part of name:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>Start<span style=\"color: gray;\">-</span>Process calc; Start<span style=\"color: gray;\">-</span>Process calc; Start<span style=\"color: gray;\">-</span>Process calc;\r\nGet<span style=\"color: gray;\">-</span>UIADesktop | Get<span style=\"color: gray;\">-</span>UIAControlChildren <span style=\"color: gray;\">-</span>ControlType Window | ?{<span style=\"color: orangered;\">$_</span>.Current.Name.Contains(<span style=\"color: #a31515;\">\"alcu\"</span>)}\r\n</pre>\r\n</div>\r\n</p>\r\n<p>2.2) if you need to collect all the dialog of the application under test, there is search down the Automaiton tree</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\"># you should run PowerShell as Asministrator to reproduce this test</span>\r\nStart<span style=\"color: gray;\">-</span>Process services.msc <span style=\"color: gray;\">-</span>PassThru | Get<span style=\"color: gray;\">-</span>UIAWindow | Get<span style=\"color: gray;\">-</span>UIAMenuItem <span style=\"color: gray;\">-</span>Name File | Invoke<span style=\"color: gray;\">-</span>UIAMenuItemClick | Get<span style=\"color: gray;\">-</span>UIAMenuItem <span style=\"color: gray;\">-</span>Name Opt<span style=\"color: gray;\">*</span> | Invoke<span style=\"color: gray;\">-</span>UIAMenuItemClick;\r\n\r\n<span style=\"color: green;\"># now we have several windows in the process mmc: the main window, the Options window </span>\r\n<span style=\"color: green;\"># and one or more internal frames of mmc itself</span>\r\n<span style=\"color: green;\"># as mmc has windows called snap-ins (or possibly even more windows I'm not aware of)</span>\r\n\r\n<span style=\"color: green;\"># in the code below, you don't need to use the Get-UIAWindow cmdlet</span>\r\n<span style=\"color: green;\"># because the last window you've successfully gotten</span>\r\n<span style=\"color: green;\"># stored in the [UIAutomation.CurrentData]::CurrentWindow variable</span>\r\nGet<span style=\"color: gray;\">-</span>UIAControlDescendants <span style=\"color: gray;\">-</span>ControlType Window | <span style=\"color: gray;\">%</span>{<span style=\"color: orangered;\">$_</span>.Current.Name;}\r\n\r\n<span style=\"color: green;\"># in this case, we have gotten only two windows, both with names</span>\r\n<span style=\"color: green;\"># in more complicated cases, you need to use several properties to select a window</span>\r\nGet<span style=\"color: gray;\">-</span>UIAControlDescendants <span style=\"color: gray;\">-</span>ControlType Window | <span style=\"color: gray;\">%</span>{Write<span style=\"color: gray;\">-</span>Host <span style=\"color: #a31515;\">\"$($_.Current.Name)`t$($_.Current.AutomaitonId)`t$($_.Current.ClassName)\"</span>;}\r\n</pre>\r\n</div>\r\n</p>\r\n<p>there also are Search- cmdlets, but these are considered legacy as they use TreeWalker what means more cross-process callc during the test:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: green;\"># the search for a specified window</span>\r\nSearch<span style=\"color: gray;\">-</span>UIAControl <span style=\"color: gray;\">-</span>Name Options <span style=\"color: gray;\">-</span>ControlType Window\r\n<span style=\"color: green;\"># the code assumes that you already have the main window</span>\r\n<span style=\"color: green;\"># and the same as the code:</span>\r\n<span style=\"color: gray;\">[</span><span style=\"color: teal;\">UIAutomation.CurrentData</span><span style=\"color: gray;\">]</span><span style=\"color: gray;\">::</span>CurrentWindow | Search<span style=\"color: gray;\">-</span>UIAControl <span style=\"color: gray;\">-</span>Name Options <span style=\"color: gray;\">-</span>ControlType Window\r\n</pre>\r\n</div>\r\nAs can be seen, the Search-UIAControl cmdlet is more specific (like every good search), whereas Get-UIAControlDescendants returns all that is of type specified.</p>\r\n<p>2.3) if you need to catch inexplicable windows like a dialog in the process of the application under test, use the Register-UIAWindowsOpenedEvent cmdlet (it's recommended to use also the Unregister-UIAEvent cmdlet from time to time during the test suite):</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>Start<span style=\"color: gray;\">-</span>Process services.msc <span style=\"color: gray;\">-</span>PassThru | Get<span style=\"color: gray;\">-</span>UIAWindow | Register<span style=\"color: gray;\">-</span>UIAWindowOpenedEvent <span style=\"color: gray;\">-</span>EventAction {<span style=\"color: blue;\">param</span>(<span style=\"color: orangered;\">$src</span>, <span style=\"color: orangered;\">$e</span>) <span style=\"color: gray;\">[</span><span style=\"color: teal;\">System.Windows.Forms.MessageBox</span><span style=\"color: gray;\">]</span><span style=\"color: gray;\">::</span>Show(<span style=\"color: #a31515;\">\"A new window is open: $($src.Cached.Name)\"</span>);};\r\nGet<span style=\"color: gray;\">-</span>UIAMenuItem <span style=\"color: gray;\">-</span>Name File | Invoke<span style=\"color: gray;\">-</span>UIAMenuItemClick | Get<span style=\"color: gray;\">-</span>UIAMenuItem <span style=\"color: gray;\">-</span>Name Opt<span style=\"color: gray;\">*</span> | Invoke<span style=\"color: gray;\">-</span>UIAMenuItemClick;\r\n</pre>\r\n</div>\r\n</p>\r\n<p>2.4) finally, if you need to catch a windows of another process that appears during the test, use the standard Register-WMIObjectEvent cmdlet (there are a lot of ways to write the code as parameters of the cmdlet can be used in various combinaitons):</p>\r\n<p>the smaple from Richard Siddaway's Blog:&nbsp;<a href=\"http://msmvps.com/blogs/richardsiddaway/archive/2009/11/07/powershell-wmi-events.aspx\">http://msmvps.com/blogs/richardsiddaway/archive/2009/11/07/powershell-wmi-events.aspx</a></p>\r\n<p>3) you can eliminate processes, it's the best choise in many situations</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>Start<span style=\"color: gray;\">-</span>Process calc; Start<span style=\"color: gray;\">-</span>Process calc; Start<span style=\"color: gray;\">-</span>Process calc;\r\nStop<span style=\"color: gray;\">-</span>Process <span style=\"color: gray;\">-</span>Name calc\r\n</pre>\r\n</div>\r\nHowever, some applications should save their data or close connections before exiting, so that you need to use something like in the item 2.1 (Get-UIADesktop | Get-UIAControlChildren: main windows are always children of the desktop) to get all of them to perform exit via main menu or hitting the Close button...</p>",
    "PostedDate": "2012-06-28T03:42:04.153-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]