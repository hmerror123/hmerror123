[
  {
    "Id": "1007506",
    "ThreadId": "434671",
    "Html": "Hi,\r<br />\nI know that SysDateTimePick32 controls is not supported in UIAutomation according to <a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ee671196(v=vs.85).aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/windows/desktop/ee671196(v=vs.85).aspx</a> but I was wondering if there is some way how to workaround it. I'm reading date via Read-UIControlName and converting that to DateTime object but I haven't manage to to find a find how to easily set time or date into control. The only thing that sort of works is sending date via Set-UIAControlKeys, but that fails on thinks like 24hour vs 12hour time format and other things depending on environment settings.\r<br />\n<br />\nAny ideas?<br />\n",
    "PostedDate": "2013-02-27T03:41:46.37-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1007734",
    "ThreadId": "434671",
    "Html": "HI ,\r<br />\nif you are talking about DateTimePicker in Windows.Forms (where is the PM/AM switcher?), we have such options:\r<br />\n1) click on the control and navigate left/right to day of week, month, date, after that navigate up or down.\r<br />\n2) a better way is to call the drop down. Need to say that by default it works strangely: coordinates of the control are floating or how to say it better: they are not stable :) This code won't work:<br />\n<pre><code>$dateTimePicker = $null;\n$dateTimePicker = Get-UIAWindow -pn testdatetimepicker32 | Get-UIAPane -AutomationId dateTimePicker*;\n\nGet-UIAPane -AutomationId dateTimePicker* | Invoke-UIAControlClick -X $dateTimePicker.Current.BoundingRectangle.X -Y 10; Get-UIAPane -n *calendar*control* | Get-UIATable | Get-UIACustom '15' | Invoke-UIAControlClick;</code></pre>\n\n3) However, if you have access to source code, you can play with the AccessibleRole property. For example, AccessibleRole ButtonDropDown makes this control a SplitButton and the following (settings date to 15th) works (though sometimes):<br />\n<pre><code>$dateTimePicker = $null;\n$dateTimePicker = Get-UIAWindow -pn testdatetimepicker32 | Get-UIASplitButton -AutomationId dateTimePicker*;\n\nGet-UIASplitButton -AutomationId dateTimePicker* | Invoke-UIAControlClick -X $dateTimePicker.Current.BoundingRectangle.X -Y 10; Get-UIAPane -n *calendar*control* | Get-UIATable | Get-UIACustom '15' | Invoke-UIAControlClick;</code></pre>\n\nThere are a variety of AccessibilityRole items available, some of them do this control button/menuitem-like.\r<br />\nBut all solutions seem unstable.<br />\n",
    "PostedDate": "2013-02-27T09:36:24.84-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1008261",
    "ThreadId": "434671",
    "Html": "Thanks for suggestions. The problem is that AM/PM switch is in control only based on system regional settings, so I would have to check for that and in general send keys seems to be not working properly. I probably would have to do it via WinAPI which is really disappointing that Microsoft didn't include DateTimePicker in UIAutomation lib :( Anyway I appreciate your help.<br />\n",
    "PostedDate": "2013-02-28T07:58:54.403-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1011724",
    "ThreadId": "434671",
    "Html": "Finally I've done it, it's not pretty but it's the only way probably. If anyone is interested this code will set DateTime into any control that supports DTM_SETSYSTEMTIME.<br />\n<pre><code>/// &lt;summary&gt;\n    /// Puts DateTime into DateTimePicker Win32 object\n    /// &lt;/summary&gt;\n    [Cmdlet(VerbsCommon.Set, &quot;DateTimePickerDate&quot;)]\n    public class SetDateTimePickerDate : Cmdlet\n    {\n        [DllImport(&quot;user32.dll&quot;)]\n        static extern IntPtr SendMessage(IntPtr hWnd, UInt32 Msg, IntPtr wParam, IntPtr lParam);\n        [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]\n        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, UIntPtr lpNumberOfBytesWritten);\n        [DllImport(&quot;kernel32.dll&quot;, SetLastError = true, ExactSpelling = true)]\n        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, AllocationType flAllocationType, MemoryProtection flProtect);\n        [DllImport(&quot;kernel32.dll&quot;, SetLastError = true, ExactSpelling = true)]\n        static extern bool VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, FreeType dwFreeType);\n        [DllImport(&quot;kernel32.dll&quot;)]\n        static extern IntPtr OpenProcess(ProcessAccessFlags dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);\n        [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]\n        static extern bool CloseHandle(IntPtr hHandle);\n\n        /// &lt;summary&gt;\n        /// DateTimePicker input object\n        /// &lt;/summary&gt;\n        [Parameter(Mandatory = true, Position = 1, ValueFromPipeline = true)]\n        public AutomationElement InputObject\n        {\n            get { return inputObject; }\n            set { inputObject = value; }\n        }\n\n        /// &lt;summary&gt;\n        /// DateTime to bet set\n        /// &lt;/summary&gt;\n        [Parameter(Mandatory = true, Position = 2)]\n        public DateTime Date\n        {\n            get { return date; }\n            set { date = value; }\n        }\n\n        AutomationElement inputObject;\n        DateTime date;\n\n        // SYSTEMTIME c++ struct to be injected into process\n        [StructLayoutAttribute(LayoutKind.Sequential)]\n        private struct SYSTEMTIME\n        {\n            public short wYear;\n            public short wMonth;\n            public short wDayOfWeek;\n            public short wDay;\n            public short wHour;\n            public short wMinute;\n            public short wSecond;\n            public short wMilliseconds;\n\n            public SYSTEMTIME(DateTime value)\n            {\n                wYear = (short)value.Year;\n                wMonth = (short)value.Month;\n                wDayOfWeek = (short)value.DayOfWeek;\n                wDay = (short)value.Day;\n                wHour = (short)value.Hour;\n                wMinute = (short)value.Minute;\n                wSecond = (short)value.Second;\n                wMilliseconds = 0;\n            }\n        }\n\n        [Flags]\n        public enum AllocationType\n        {\n            Commit = 0x1000,\n            Reserve = 0x2000,\n            Decommit = 0x4000,\n            Release = 0x8000,\n            Reset = 0x80000,\n            Physical = 0x400000,\n            TopDown = 0x100000,\n            WriteWatch = 0x200000,\n            LargePages = 0x20000000\n        }\n\n        [Flags]\n        public enum MemoryProtection\n        {\n            Execute = 0x10,\n            ExecuteRead = 0x20,\n            ExecuteReadWrite = 0x40,\n            ExecuteWriteCopy = 0x80,\n            NoAccess = 0x01,\n            ReadOnly = 0x02,\n            ReadWrite = 0x04,\n            WriteCopy = 0x08,\n            GuardModifierflag = 0x100,\n            NoCacheModifierflag = 0x200,\n            WriteCombineModifierflag = 0x400\n        }\n\n        [Flags]\n        enum ProcessAccessFlags : uint\n        {\n            All = 0x001F0FFF,\n            Terminate = 0x00000001,\n            CreateThread = 0x00000002,\n            VMOperation = 0x00000008,\n            VMRead = 0x00000010,\n            VMWrite = 0x00000020,\n            DupHandle = 0x00000040,\n            SetInformation = 0x00000200,\n            QueryInformation = 0x00000400,\n            Synchronize = 0x00100000\n        }\n\n        [Flags]\n        public enum FreeType\n        {\n            Decommit = 0x4000,\n            Release = 0x8000,\n        }\n\n        const uint DTM_FIRST = 0x1000;\n        const uint DTM_SETSYSTEMTIME = DTM_FIRST + 2;\n        const ushort GDT_VALID = 0;\n        const uint WM_COMMAND = 0x0111;\n\n        private void injectMemory(int procId, byte[] buffer, out IntPtr hndProc, out IntPtr lpAddress)\n        {\n            // open process and get handle\n            hndProc = OpenProcess(ProcessAccessFlags.All, true, procId);\n\n            if (hndProc == (IntPtr)0)\n            {\n                AccessViolationException ex = new AccessViolationException(&quot;Unable to attach to process with an id &quot; + procId);\n                ThrowTerminatingError(new ErrorRecord(ex, &quot;AccessDenined&quot;, ErrorCategory.SecurityError, null));\n            }\n\n            // allocate memory for object to be injected\n            lpAddress = VirtualAllocEx(hndProc, (IntPtr)null, (uint)buffer.Length,\n                AllocationType.Commit | AllocationType.Reserve, MemoryProtection.ExecuteReadWrite);\n\n            if (lpAddress == (IntPtr)0)\n            {\n                AccessViolationException ex = new AccessViolationException(&quot;Unable to allocate memory to proces with an id &quot; + procId);\n                ThrowTerminatingError(new ErrorRecord(ex, &quot;AccessDenined&quot;, ErrorCategory.SecurityError, null));\n            }\n\n            // write data to process\n            uint wrotelen = 0;\n            WriteProcessMemory(hndProc, lpAddress, buffer, (uint)buffer.Length, (UIntPtr)wrotelen);\n\n            if (Marshal.GetLastWin32Error() != 0)\n            {\n                AccessViolationException ex = new AccessViolationException(&quot;Unable to write memory to process with an id &quot; + procId);\n                ThrowTerminatingError(new ErrorRecord(ex, &quot;AccessDenined&quot;, ErrorCategory.SecurityError, null));\n            }\n        }\n\n        protected override void ProcessRecord()\n        {\n            base.ProcessRecord();\n\n            // initialize SYSTEMTIME\n            int structMemLen = Marshal.SizeOf(typeof(SYSTEMTIME));\n            byte[] buffer = new byte[structMemLen];\n            SYSTEMTIME sysTime = new SYSTEMTIME(date);\n\n            // get memory size of SYSTEMTIME\n            IntPtr dataPtr = Marshal.AllocHGlobal(structMemLen);\n            Marshal.StructureToPtr(sysTime, dataPtr, true);\n            Marshal.Copy(dataPtr, buffer, 0, structMemLen);\n            Marshal.FreeHGlobal(dataPtr);\n\n            IntPtr hndProc = IntPtr.Zero;\n            IntPtr lpAddress = IntPtr.Zero;\n            int procId = inputObject.Current.ProcessId;\n            int inputHandle = inputObject.Current.NativeWindowHandle;\n\n            try\n            {\n                // inject new SYSTEMTIME into process memory\n                injectMemory(procId, buffer, out hndProc, out lpAddress);\n\n                // set DateTime to object via pointer to injected SYSTEMTIME\n                SendMessage((IntPtr)inputHandle, DTM_SETSYSTEMTIME, (IntPtr)GDT_VALID, lpAddress);\n            }\n            finally\n            {\n                // release memory and close handle\n                if (lpAddress != (IntPtr)0 || lpAddress != IntPtr.Zero)\n                {\n                    // we don't really care about the result because if release fails there is nothing we can do about it\n                    bool relState = VirtualFreeEx(hndProc, lpAddress, 0, FreeType.Release);\n                }\n\n                if (hndProc != (IntPtr)0 || hndProc != IntPtr.Zero)\n                {\n                    CloseHandle(hndProc);\n                }\n            }\n        }\n    }</code></pre>\n\n",
    "PostedDate": "2013-03-07T04:50:57.673-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1011747",
    "ThreadId": "434671",
    "Html": "Hi Crowcz,\r<br />\nwhile I've been having a fever, you resolved all issues :) Would you like to add your cmdlet to the UIAutomation project?<br />\n",
    "PostedDate": "2013-03-07T05:31:32.51-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1015842",
    "ThreadId": "434671",
    "Html": "Sure, I would love to. How do you want to do it? I've also created some window pattern cmdlets (to maximize, restore, close etc.) which were not finished in current version, maybe you might be interested in those aswell.<br />\n",
    "PostedDate": "2013-03-15T04:24:41.29-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1016055",
    "ThreadId": "434671",
    "Html": "I'd like to incorporate them (I thought a time ago to implement WindowPattern cmdlets. However, I changed the employer and the current one provides me with applications that are mostly of fixed size, i.e. wizards and dialogs :)).\r<br />\nPeople say that the right method (for cutting-edge guys :)) to upload code is a pull request on github.\r<br />\nHere is what and how to do:<br />\n<ol>\n<li>take a look at this <a href=\"https://help.github.com/articles/using-pull-requests\" rel=\"nofollow\">page</a>, sections Fork &amp; Pull, Before You Begin, Initiating The Pull Request</li>\n<li>login to github.com with a new or existing account</li>\n<li>fork the repository <a href=\"https://github.com/apetrovskiy/STUPS\" rel=\"nofollow\">https://github.com/apetrovskiy/STUPS</a></li>\n<li>add files/code to your fork, in IDE or directly on github.com</li>\n<li>press the Pull request button at the top of the page, shortly write what changes are about</li>\n<li>\nI'll get your pull request and commit code to the main repository (technically, I'll change standard WriteError and WriteObject to my own wrappers, linked cmdlet classes to a class that derives from PSCmdlet indirectly, cut out the meaningful code and put it in a class for code, etc, etc - to make the framework consistent in term of test results reporting, etc)<br />\n</li>\n</ol>\nI'm relatively new to github (a kind of dinosaur:)), but I suddenly fell in love with it.<br />\n",
    "PostedDate": "2013-03-15T11:46:00.11-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]